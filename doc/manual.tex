\documentclass[letter,10pt]{article}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{epsfig}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{hyperref}


%opening
\title{FLANN - Fast Library for Approximate Nearest Neighbors\\[0.5cm] User
Manual\\[1cm]}

\author{Marius Muja, mariusm@cs.ubc.ca\\David Lowe, lowe@cs.ubc.ca}

\date{\today}
\begin{document}


 \begin{titlepage}
\vspace{10cm}
\maketitle
\thispagestyle{empty}
 \end{titlepage}


\section{Introduction}

We can define the \emph{nearest neighbor search (NSS)} problem in the
following way: given a set of points $P=p_1,p_2,\dots,p_n$ in a metric
space $X$, these points must be preprocessed in such a way that given a new
query point $q \in X$, finding the point in $P$ that is nearest to $q$ can
be done quickly.

The problem of nearest neighbor search is one of major importance in a
variety of applications such as image recognition, data compression,
pattern recognition and classification, machine learning,  document
retrieval systems, statistics and data analysis. However, solving this
problem in high dimensional spaces seems to be a very difficult task and
there is no algorithm that performs significantly better than the standard
brute-force search. This has lead to an increasing interest in a class of
algorithms that perform approximate nearest neighbor searches, which have
proven to be a good-enough approximation in most practical applications and
in most cases, orders of magnitude faster that the algorithms performing
the exact searches.

FLANN (Fast Library for Approximate Nearest Neighbors) is a library for
performing fast approximate nearest neighbor searches. FLANN is written in
the C++ programming language. FLANN can be easily used in many contexts
through the C, MATLAB and Python bindings provided with the library.



\subsection{Quick Start}
\label{sec:quickstart}


This section contains small examples of how to use the FLANN library from
different programming languages (C/C++, MATLAB and Python) and from the
command line.

\begin{itemize}

\item \textbf{C/C++}
\begin{Verbatim}[fontsize=\scriptsize,frame=single]
// file flann_example.cc

#include "flann.h"
#include <stdio.h>
#include <assert.h>

// Function that reads a dataset
float* read_points(char* filename, int *rows, int *cols);

int main(int argc, char** argv)
{
   int rows,cols;
   int t_rows, t_cols;
   float speedup;

   // read dataset points from file dataset.dat
   float* dataset = read_points("dataset.dat", &rows, &cols);
   float* testset = read_points("testset.dat", &t_rows, &t_cols);

   // points in dataset and testset should have the same dimensionality
   assert(cols==t_cols);

   // number of nearest neighbors to search
   int nn = 3;
   // allocate memory for the nearest-neighbors indices
   int* result = new int[t_rows*nn];
   // allocate memory for the distances
   float* dists = new int[t_rows*nn];

   // index parameters are stored here
   FLANNParameters p;
   // want 90% target precision
   // the rest of the parameters are automatically computed
   p.target_precision = 0.9;  
   // compute the 3 nearest-neighbors of each point in the testset
   flann_find_nearest_neighbors(dataset, rows, cols, testset, t_rows,
result, dists, nn, &p);

   // ...

   delete[] dataset;
   delete[] testset;
   delete[] result;
   delete[] dists;

   return 0;
}

\end{Verbatim}



\item \textbf{MATLAB}
\begin{Verbatim}[fontsize=\scriptsize,frame=single]
% create random dataset and test set
dataset = single(rand(128,10000));
testset = single(rand(128,1000));

% define index and search parameters
params.algorithm = 'kdtree';
params.trees = 8;
params.checks = 64;

% perform the nearest-neighbor search
[result, dists] = flann_search(dataset,testset,5,params);
\end{Verbatim}

\item \textbf{Python}
\begin{Verbatim}[fontsize=\scriptsize,frame=single]
from pyflann import *
from numpy import *
from numpy.random import *

dataset = rand(10000, 128)
testset = rand(1000, 128)

flann = FLANN()
result,dists = flann.nn(dataset,testset,5,algorithm="kmeans",
               branching=32, iterations=7, checks=16);
\end{Verbatim}

\item \textbf{Command line application}



\begin{Verbatim}[fontsize=\scriptsize,frame=single]
$ flann compute_nn --input-file=dataset.dat --test-file=testset.dat 
--algorithm=kdtree --trees=8 --checks=64 --nn=5 --output-file=nn.dat
Reading input dataset from dataset.dat
Building index
Building index took: 0.76
Reading test dataset from testset.dat
Searching for nearest neighbors
Searching took 0.06 seconds
Writing matches to nn.dat
\end{Verbatim}

\end{itemize}



\section{Downloading and compiling FLANN}

FLANN can be downloaded from the following address:
\begin{center}
\texttt{http://www.cs.ubc.ca/$\sim$mariusm/flann}
\end{center}

After downloading and unpacking, the following files and directories should
be present:
\begin{itemize}
\item \texttt{src}: directory containg the source files
\item \texttt{doc}: directory containg this documentation
\item \texttt{bin}: directory various for scripts and binary files
\end{itemize}

In addition, the FLANN libary will install itself in the directory
\texttt{build} (unless overridden by the \texttt{CMAKE\_INSTALL\_PREFIX} variable).
The \texttt{build} directory will have the following structure:
\begin{itemize}
\item \texttt{bin}: contains the command line application (\texttt{flann}) and other binary files
\item \texttt{lib}: contains the compiled libraries (\texttt{libflann.so} and \texttt{libflann\_s.a} for linux)
\item \texttt{include}: contains the C header files
\item \texttt{matlab}: contains the MATLAB wrapper functions and a MEX (Matlab EXecutable) file
\item \texttt{python}: contains the python bindings
\end{itemize}


To compile the flann library the \textit{CMake}\footnote{http://www.cmake.org/} build system is required.
Below is an example of how the FLANN library can be compiled on Linux (replace x.y with the corresponding version number).
\begin{Verbatim}[fontsize=\scriptsize,frame=single]
$ cd flann-x.y-src
$ mkdir tmp
$ cd tmp
$ cmake ../src -DCMAKE_BUILD_TYPE=release
$ make install
\end{Verbatim}

On windows the steps are similar:

\begin{Verbatim}[fontsize=\scriptsize,frame=single]
> cd flann-x.y-src
> md tmp
> cd tmp
> cmake ..\src -G ``NMake Makefiles'' -DCMAKE_BUILD_TYPE=release
> nmake install
\end{Verbatim}


\section{Using FLANN}

\subsection{Using FLANN from MATLAB}


The FLANN library can be used from MATLAB through the following wrapper
functions: \texttt{flann\_build\_index}, \texttt{flann\_search} and
\texttt{flann\_free\_index}. The \texttt{flann\_build\_index} function
creates a search index from the dataset points, \texttt{flann\_search} uses
this index to perform nearest-neighbor searches and
\texttt{flann\_free\_index} deletes the index and releases the memory it
uses.

Note that in the binary distribution of FLANN the MEX file is linked against
the shared version of FLANN (\texttt{flann.so} or \texttt{flann.dll}), so on Linux you must set the 
LD\_LIBRARY\_PATH environment variable accordingly prior to starting MATLAB. On Windows is enough
to have \texttt{flann.dll} in the same directory with the MEX file.

The following sections describe in more detail the FLANN matlab wrapper
functions and show examples of how they may be used.

\subsubsection{flann\_build\_index}
\label{sec:flann_build_index}

This function creates a search index from the initial dataset of points,
index used  later for fast nearest-neighbor searches in the dataset.

\begin{Verbatim}
[index, parameters, speedup] = flann_build_index(dataset,build_params);
\end{Verbatim}


The arguments passed to the \texttt{flann\_build\_index} function have the
following meaning:
\begin{description}

\item [\texttt{dataset}] is a $d \times n$ matrix containing $n$
$d$-dimensional points

\item [\texttt{build\_params}] - is a MATLAB structure containing the
parameters passed to the function.

\end{description}

Depending on the contents of the \texttt{build\_params} structure, the
function has two different behaviors. If the structure contains a field
that specifies the index type to create the function will create an index
of that type (using index parameters which also have to be included in
the \texttt{build\_params} structure). If the index and index parameters
are not specified directly the function will first try to automatically
detect the best index and index parameters to use for nearest neighbor
search in the provided dataset.

\paragraph{Using automatic index and parameter configuration}
When using automatic configuration the  \texttt{build\_params} structure
must contain the following fields:


\begin{description}

\item[\texttt{target\_precision}] - is a number between 0 and 1 specifying the
percentage of the approximate nearest-neighbor searches that return the
exact nearest-neighbor. Using a higher value for this parameter gives
more
accurate results, but the searching takes longer. The optimum value
usually
depends on the application.

\item[\texttt{build\_weight}] - specifies the importance of the
index build time reported to the nearest-neighbor search time. In some
applications it's acceptable for the index build step to take a long time
if the subsequent searches in the index can be performed very fast. In
other applications it's required that the index be build as fast as
possible even if that leads to slightly longer search times. (Default
value: 0.01)

\item[\texttt{memory\_weight}] - is used to specify the tradeoff between
time (index build time and search time) and memory used by the index. A
value less than 1 gives more importance to the time spent and a value
greater than 1 gives more importance to the memory usage.

\item[\texttt{sample\_fraction}] - is a number between 0 and 1 indicating what fraction
of the dataset to use in the automatic parameter configuration algorithm. Running the 
algorithm on the full dataset gives the most accurate results, but for
very large datasets can take longer than desired. In such case, using just a fraction of the
data helps speeding up this algorithm, while still giving good approximations of the
optimum parameters.

 \end{description}


\paragraph{Specifying the index type and parameters manually}

Because the parameter estimation step is costly, it is
possible to skip this step and reuse the already computed parameters the
next time an index is created from similar data points (coming from the
same distribution). To specify the index type and the index parameters
manually, the \texttt{build\_params} structure must contain the following
fields:



\begin{description}
\item[\texttt{algorithm}] - the algorithm to use for building the index.
The possible values are: \texttt{'linear'}, \texttt{'kdtree'},
\texttt{'kmeans'} and \texttt{'composite'}. The \texttt{'linear'} option
does not create any index, it uses brute-force search in the original
dataset points, \texttt{'kdtree'} creates one or more randomized kd-trees,
\texttt{'kmeans'} creates a hierarchical kmeans clustering tree and
\texttt{'composite'} is a mix of both kdtree and kmeans trees.
\item[\texttt{trees}] - the number of randomized kd-trees to
create. This parameter is required only when the algorithm used is
\texttt{'kdtree'}.
\item[\texttt{branching}] - the branching factor to use for
the hierarchical kmeans tree creation. While kdtree is always a binary
tree, each node in the kmeans tree may have several branches depending on
the value of this parameter. This parameter is required only when the
algorithm used is \texttt{'kmeans'}.
\item[\texttt{iterations}] - the maximum number of iterations to
use in the kmeans clustering stage when building the kmeans tree. A value
of -1 used here means that the kmeans clustering should be performed until
convergence. This parameter is required only when the algorithm used is
\texttt{'kmeans'}.
\item[\texttt{centers\_init}] - the algorithm to use for selecting the initial
centers when performing a kmeans clustering step. The possible values are
'random' (picks the initial cluster centers randomly), 'gonzales' (picks the
initial centers using the Gonzales algorithm) and 'kmeanspp' (picks the initial
centers using thealgorithm suggested in \cite{arthur_kmeanspp_2007}). If this
parameters is omitted, the default value is 'random'.

\item[\texttt{cb\_index}] - this parameter (cluster boundary index) influences the
way exploration is performed in the hierarchical kmeans tree. When \texttt{cb\_index} is zero
the next kmeans domain to be explored is choosen to be the one with the closest center. 
A value greater then zero also takes into account the size of the domain.

\end{description}

The above parameters have a big impact on the performance of the new search
index (nearest-neighbor search time) and on the time and memory required to
build the index. The optimum parameter values depend on the dataset
characteristics (number of dimensions, distribution of points in the
dataset) and on the application domain (desired precision for the
approximate nearest neighbor searches).




The \texttt{flann\_build\_index} function returns the newly created
\texttt{index}, the \texttt{parameters} used for creating the index and, if
automatic configuration was used, an estimation of the \texttt{speedup}
over linear search that is achieved when searching the index.




\subsubsection{flann\_search}

This function performs nearest-neighbor searches using the index already
created:
\begin{Verbatim}
[result, dists] = flann_search(index, testset, k, parameters);
\end{Verbatim}

The arguments required by this function are:
\begin{description}
\item[\texttt{index}] - the index returned by the
\texttt{flann\_build\_index} function
\item[\texttt{testset}] - a $d \times m$ matrix containing $m$ test points
whose k-nearest-neighbors need to be found
\item[\texttt{k}] - the number of nearest neighbors to be returned for each
point from \texttt{testset}
\item[\texttt{parameters}] - structure containing the search parameters.
Currently it has only one member, \texttt{parameters.checks}, denoting the
number of times the tree(s) in the index should be recursively traversed. A
higher value for this parameter would give better search precision, but
also take more time. If automatic configuration was used when the
index was created, the number of checks required to achieve the specified
precision is also computed. In such case, the parameters structure returned
by the \texttt{flann\_build\_index} function can be passed directly to the
\texttt{flann\_search} function.
\end{description}

The function returns two matrices, each of size $k \times m$. The first one contains, in which each column, the indexes (in the dataset matrix) of the $k$ nearest neighbors of the corresponding point from testset, while the second one contains the corresponding distances. The second matrix can be omitted when making the call if the distances to the nearest neighbors are not needed. 

For the case where a single search will be performed with each index, the
\texttt{flann\_search} function accepts the dataset instead of the index as
first argument, in which case the index is created searched and then
deleted in one step. In this case the parameters structure passed to the
\texttt{flann\_search} function must also contain the fields of the
\texttt{build\_params} structure that would normally be passed to the
\texttt{flann\_build\_index} function if the index was build separately.
\begin{Verbatim}
[result, dists] = flann_search(dataset, testset, k, parameters);
\end{Verbatim}


\subsubsection{flann\_free\_index}

This function must be called to delete an index and release all the memory
used by it:
\begin{Verbatim}
flann_free_index(index);
\end{Verbatim}

\subsubsection{Examples}

Let's look at a few examples showing how the functions described above are
used:

\paragraph{Example 1:}

In this example the index is constructed using automatic parameter estimation, requesting 90\% as desired precision and using the default values for the build time and memory usage factors. The index is then used to search for the nearest-neighbors of the points in the testset matrix and finally the index is deleted.

\begin{Verbatim}[fontsize=\footnotesize,frame=single]

dataset = single(rand(128,10000));
testset = single(rand(128,1000));

build_params.target_precision = 0.9;
build_params.build_weight = 0.01;
build_params.memory_weight = 0;

[index, parameters] = flann_build_index(dataset, build_params);

result = flann_search(index,testset,5,parameters);

flann_free_index(index);

\end{Verbatim}




% \bibliographystyle{alpha}
% \bibliography{references}


\paragraph{Example 2:}

In this example the index constructed with the parameters specified manually.

\begin{Verbatim}[fontsize=\footnotesize,frame=single]

dataset = single(rand(128,10000));
testset = single(rand(128,1000));

index = flann_build_index(dataset,struct('algorithm','kdtree','trees',8));

result = flann_search(index,testset,5,struct('checks',128));

flann_free_index(index);

\end{Verbatim}

\paragraph{Example 3:}

In this example the index creation, searching and deletion are all performed in one step:

\begin{Verbatim}[fontsize=\footnotesize,frame=single]

dataset = single(rand(128,10000));
testset = single(rand(128,1000));

[result,dists] = flann_search(dataset,testset,5,struct('checks',128,'algorithm',...
    'kmeans','branching',64,'iterations',5));

\end{Verbatim}

\subsection{Using FLANN from C/C++}

FLANN can be easily used in C/C++ programs through the C bindings provided
with the library. To use the C bindings, the library header file
\texttt{flann.h} (located in the \texttt{build/include} directory) must be
included. Also the compiler must be told where to look for that file, by
adding the \texttt{build/include} directory to the compiler include path
(all the paths in this document are specified relative to the library main
directory). The directory can be added to the compiler include
path using the \texttt{-I} compiler flag (on most Unix/Linux systems). When
linking the C/C++ application the \texttt{libflann\_s.a} (for linking statically) or
the \texttt{libflann.so} (for linking dynamically) libraries must be linked in. 
This is done using the \texttt{-l} compiler flag followed by the library name
(eg. \texttt{-lflann}) and by specifying the library search path
(\texttt{build/lib}) with the \texttt{-L} flag. The entire compile command
that must be used will look like this:
\begin{Verbatim}[fontsize=\footnotesize]
g++ flann_example.cc -I build/include -L build/lib -o flann_example -lflann
\end{Verbatim}

The following section describes the C bindings offered by the FLANN
library:

\paragraph{flann\_build\_index()}
\begin{Verbatim}[fontsize=\footnotesize,frame=single]
FLANN_INDEX flann_build_index(float* dataset,
	int rows,
	int cols,
	float* speedup,
	struct FLANNParameters* flann_params);
\end{Verbatim}
This function builds an index and return a reference to it. The arguments
expected by this function are as follows:
\begin{description}
 \item[dataset, rows and cols] - are used to specify the input dataset of
points: dataset is a pointer to a $\rm{rows} \times \rm{cols}$ matrix
stored in row-major order.
\item [speedup] - is used to return the approximate speedup over linear
search achieved when using the automatic index and parameter configuration
(see section \ref{sec:flann_build_index})
\item [flann\_params] - is a structure containing the parameters passed to
the function. This structure is defined as follows:
\begin{Verbatim}[fontsize=\footnotesize]
struct FLANNParameters {
    flann_algorithm_t algorithm; // the algorithm to use (see constants.h)
    int checks;                // how many leafs (features) to check in one search
    float cb_index;            // cluster boundary index. Used when searching the kmeans tree
    int trees;                 // number of randomized trees to use (for kdtree)
    int branching;             // branching factor (for kmeans tree)
    int iterations;            // max iterations to perform in one kmeans cluetering (kmeans tree)
    flann_centers_init_t centers_init;   // algorithm used for picking the initial cluster centers for kmeans tree
    float target_precision;    // precision desired (used for autotuning, -1 otherwise)
    float build_weight;        // build tree time weighting factor
    float memory_weight;       // index memory weigthing factor
    float sample_fraction;     // what fraction of the dataset to use for autotuning

    flann_log_level_t log_level;             // determines the verbosity of each flann function
    char* log_destination;     // file where the output should go, NULL for the console
    long random_seed;          // random seed to use
};
\end{Verbatim}

The \texttt{algorithm} and \texttt{centers\_init} fields can take the
following values:
\begin{Verbatim}[fontsize=\footnotesize]
enum flann_algorithm_t {
    LINEAR = 0,
    KDTREE = 1,
    KMEANS = 2,
    COMPOSITE = 3,
};

enum flann_centers_init_t {
    CENTERS_RANDOM = 0,
    CENTERS_GONZALES = 1,
    CENTERS_KMEANSPP = 2
};
\end{Verbatim}
The \texttt{algorithm} field is used to manually select the type of index
used. The \texttt{centers\_init} field specifies how to choose the inital
cluster centers when performing the hierarchical k-means clustering (in
case the algorithm used is k-means): \texttt{CENTERS\_RANDOM} chooses the
initial centers randomly, \texttt{CENTERS\_GONZALES} chooses the
initial centers to be spaced apart from each other by using Gonzales' algorithm
and \texttt{CENTERS\_KMEANSPP} chooses the initial centers using the algorithm
proposed in \cite{arthur_kmeanspp_2007}.

The fields: \texttt{checks}, \texttt{cb\_index},  \texttt{trees}, \texttt{branching},  \texttt{iterations}, \texttt{target\_precision}, \texttt{build\_weight}, \texttt{memory\_weight} and \texttt{sample\_fraction} have the
same meaning as described in \ref{sec:flann_build_index}.


The \texttt{random\_seed} field contains the random seed useed to initialize the random
number generator. 

The field \texttt{log\_level} controls the verbosity of the messages generated by the FLANN
library functions. It can take the following values:
\begin{Verbatim}[fontsize=\footnotesize]
enum flann_log_level_t {
    LOG_NONE = 0,
    LOG_FATAL = 1,
    LOG_ERROR = 2,
    LOG_WARN = 3,
    LOG_INFO = 4
};
\end{Verbatim}
The field \texttt{log\_destination} contains the name of a file where these messages
should be generated or NULL for the console.
\end{description}


\paragraph{flann\_find\_nearest\_neighbors\_index()}
\begin{Verbatim}[fontsize=\footnotesize,frame=single]
int flann_find_nearest_neighbors_index(FLANN_INDEX index_id,
	float* testset,
	int trows,
	int* indices,
	float* dists,
	int nn,
	int checks,
	struct FLANNParameters* flann_params);
\end{Verbatim}
This function searches for the nearest neighbors of the
\texttt{testset} points using an index already build and referenced by
\texttt{index\_id}. The \texttt{testset} is a matrix stored in row-major format
with \texttt{trows} rows and the same number of columns as the dimensionality
of the points used to build the index. The function computes \texttt{nn}
nearest neighbors for each point in the \texttt{testset} and stores them in the
\texttt{indices} matrix (which is a $\rm{trows} \times \rm{nn}$ matrix stored in
row-major format). The memory for the \texttt{result} matrix must be allocated
before the \texttt{flann\_find\_nearest\_neighbors\_index()} function is
called. The distances to the nearest neighbors found are stored in the \texttt{dists}
matrix. The \texttt{checks} parameter specifies how many tree traversals should
be performed during the search.



\paragraph{flann\_find\_nearest\_neighbors()}
\begin{Verbatim}[fontsize=\footnotesize,frame=single]
int flann_find_nearest_neighbors(float* dataset,
	int rows,
	int cols,
	float* testset,
	int trows,
	int* indices,
	float* dists,
	int nn,
	struct FLANNParameters* flann_params);
\end{Verbatim}
This function is similar to the
\texttt{flann\_find\_nearest\_neighbors\_index()} function, but instread of
using a previously constructed index, it constructs the index, does the nearest
neighbor search and deletes the index in one step.

\paragraph{flann\_radius\_search()}

\begin{Verbatim}[fontsize=\footnotesize,frame=single]
int flann_radius_search(FLANN_INDEX index_ptr,
	float* query,   /* query point */
	int* indices, /* array for storing the indices */
	float* dists, /* similar, but for storing distances */
	int max_nn,  /* size of arrays indices and dists */
	float radius, /* search radius (squared radius for euclidian metric) */
	int checks,  /* number of features to check, sets the level
			 of approximation */
	FLANNParameters* flann_params);
\end{Verbatim}

This function performs a radius search to single query point. The indices of the neighbors found and
the distances to them are stored in the \texttt{indices} and dists \texttt{arrays}. The \texttt{max\_nn} parameter sets the limit of the
neighbors that will be returned (the size of the \texttt{indices} and \texttt{dists} arrays must be at least \texttt{max\_nn}).


\paragraph{flann\_free\_index()}
\begin{Verbatim}[fontsize=\footnotesize,frame=single]
int flann_free_index(FLANN_INDEX index_id,
	struct FLANNParameters* flann_params);
\end{Verbatim}
This function deletes a previously constructed index and frees all the memory
used by it.








\bigskip

See section \ref{sec:quickstart} for an example of how to use the C/C++
bindings.

\subsection{Using FLANN from python}

FLANN can be used from python programs using the python bindings distributed
with the library. The python bindings can be installed on a system using the
distutils script provided (setup.py), by running the following command in the
build/python directory:
\begin{Verbatim}[fontsize=\footnotesize,frame=single]
$ python setup.py install
\end{Verbatim}
The python bindings also require the numpy package to be installed.

To use the python FLANN bindings the package \texttt{pyflann} must be imported
(see the python example in section \ref{sec:quickstart}). This package contains
a class called FLANN that handles the nearest-neighbor search operations. This
class containg the following methods:
\begin{description}
\item [\texttt{def build\_index(self, dataset, **kwargs)}] :\\
    This method builds and internally stores an index to be used for future
nearest neighbor matchings. It erases any previously stored index, so in order
to work with multiple indexes, multiple instances of the FLANN class must be
used. The \texttt{dataset} argument must be a 2D numpy array or a matrix. The
rest of the arguments that can be passed to the method are the same as
 those used in the \texttt{build\_params} structure from
section \ref{sec:flann_build_index}. Similar to the MATLAB version, the index
can be created using manually specified parameters or the parameters can be
automatically computed (by specifying the target\_precision, build\_weight and
memory\_weight arguments).

The method returns a dictionary containing the parameters used to construct the
index. In case automatic parameter selection is used, the dictionary will also
contain the number of checks required to achieve the desired target precision
and an estimation of the speedup over linear search that the library will
provide.


\item [\texttt{def nn\_index(self, testset, num\_neighbors = 1, **kwargs)}] :\\
    This method searches for the \texttt{num\_neighbors} nearest neighbors of
each point in \texttt{testset} using the index computed by
\texttt{build\_index}. Additionally, a parameter called checks, denoting the
number of times the index tree(s) should be recursivelly searched, must be
given.

Example:
\begin{Verbatim}[fontsize=\scriptsize,frame=single]
from pyflann import *
from numpy import *
from numpy.random import *

dataset = rand(10000, 128)
testset = rand(1000, 128)

flann = FLANN()
params = flann.build_index(dataset, target_precision=0.9, log_level = "info");
print params

result, dists = flann.nn_index(testset,5, checks=params["checks"]);
\end{Verbatim}

\item[\texttt{def nn(self, dataset, testset, num\_neighbors = 1, **kwargs)}]:\\
    This method builds the index, performs the nearest neighbor search and
deleted the index, all in one step.

\item [\texttt{def delete\_index(self, **kwargs)}] :\\
    This method deletes the current index and all the data associated with it.
It should be called to free all the memory used by the index.

\end{description}


See section \ref{sec:quickstart} for an example of how to use the Python
bindings.


\subsection{Using the \texttt{flann} command line application}

The FLANN distribution also contains a command line application that can be
used to perform nearest-neighbor searches using datasets stored in files. The
application can read datasets stored in CSV format, space-separated values or
raw binary format.

The command line application takes a command name as the first argument and
then the arguments for that command:
\begin{Verbatim}[fontsize=\footnotesize,frame=single]
$ flann
Usage: flann.py [command commans_args]

Comamnds:
      generate_random
      compute_gt
      compute_nn
      autotune
      sample_dataset
      cluster
      run_test

For command specific help type: flann.py <command> -h
\end{Verbatim}

To see the possible arguments for each command, use \texttt{flann help
<command>}. For example:

\begin{Verbatim}[fontsize=\footnotesize,frame=single]
$ flann run_test -h
Usage: flann.py [command command_args]

Options:
  -h, --help            show this help message and exit
  -i FILE, --input-file=FILE
                        Name of file with input dataset
  -a ALGORITHM, --algorithm=ALGORITHM
                        The algorithm to use when constructing the index
                        (kdtree, kmeans...)
  -r TREES, --trees=TREES
                        Number of parallel trees to use (where available, for
                        example kdtree)
  -b BRANCHING, --branching=BRANCHING
                        Branching factor (where applicable, for example
                        kmeans) (default: 2)
  -C CENTERS_INIT, --centers-init=CENTERS_INIT
                        How to choose the initial cluster centers for kmeans
                        (random, gonzales) (default: random)
  -M MAX_ITERATIONS, --max-iterations=MAX_ITERATIONS
                        Max iterations to perform for kmeans (default: until
                        convergence)
  -l LOG_LEVEL, --log-level=LOG_LEVEL
                        Log level (none < fatal < error < warning < info)
                        (Default: info)
  -t FILE, --test-file=FILE
                        Name of file with test dataset
  -m FILE, --match-file=FILE
                        File with ground truth matches
  -n NN, --nn=NN        Number of nearest neighbors to search for
  -c CHECKS, --checks=CHECKS
                        Number of times to restart search (in best-bin-first
                        manner)
  -P PRECISION, --precision=PRECISION
                        Run the test until reaching this precision
  -K NUM, --skip-matches=NUM
                        Skip the first NUM matches at test phase

\end{Verbatim}


\section{Acknowledgments}

Many thanks to Hoyt Koepke for his initial work on the python bindings.




\bibliographystyle{alpha}
\bibliography{references}

\end{document}
