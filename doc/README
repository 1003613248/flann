
             Fast detection of approximate nearest neighbors
             -----------------------------------------------
                    David Lowe (lowe@cs.ubc.ca)
                          January 2006

This directory contains sample code for finding the approximate
nearest neighbors of a vector.  It contains the following files:

nn.c       This contains the core code for the nearest-neighbor algorithm.
             See the header of this file for the external interface.
util.c     Some utility routines, including a pooled memory allocator.
testnn.c   This provides a test framework that reads a set of vectors from
             a file and runs timing experiments.  This is just to provide an
             example of usage and would be replaced for a new application.
sift10K.nn This is a file of test data containing 10,000 128D SIFT vectors
             in a simple ASCII format.  I can also provide larger files with
             30K or 100K examples.  Each vector contains its true nearest
             neighbor, as well as a flag indicating whether the true neighbor
             is actually a correct match based on ground truth.


Compile and test
----------------

To test the code, run the following in Linux:
% make
% testnn <sift10K.nn

This will print out timing and accuracy results for different choices
of the number of checked nodes.  For example, the following table
shows that when checking at most 128 nodes out of the 10,000 inputs,
over 97% of the "useful" neighbors are correctly found.  The total
computation time in this case is 0.53 seconds to build the trees and
1.58 seconds to perform lookup on the 10,000 input vectors.  As the
distance computations are still the major cost, this is at least 50
times faster than linear search.  Larger speedups are obtained for
larger datasets.

--------------------------------------------------------------

Time to build 4 random trees for 10000 vectors:  0.53 seconds

  Nodes    % correct   % of good     Time     Time/vector
 checked   neighbors    matches    (seconds)      (ms)
 -------   ---------   ---------   ---------  -----------
      8      26.76       43.23        0.13       0.013
     32      63.53       89.09        0.45       0.045
    128      84.10       97.68        1.58       0.158
    512      95.55       99.68        5.84       0.584
--------------------------------------------------------------


Using the code
--------------

There are two formats for the input vectors.  The standard one used
for SIFT is to represent each value as an unsigned char in the range
[0,255].  This has the advantage of minimizing memory usage and yet
still has plenty of precision for finding the best match.  However,
for Matlab or more general usage, it will be easier to just use float
values.  This uses more memory for the vectors, but does not increase
computation time significantly.  Therefore, all routines are provided
in a standard version and one with "Float" appended to the name to use
float vectors instead.

When using float vectors, you first call the routine BuildIndexFloat
to create an Index structure that contains the k-d trees.  Then you
call FindNeighborsFloat to find the nearest neighbors of a
particular vector using this index.  See the header of nn.c for
details.

