\documentclass[letter,10pt]{article}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{epsfig}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{hyperref}


%opening
\title{FLANN - Fast Approximate Nearest Neighbors\\User Guide}
%\author{Marius Muja}

\date{}
\begin{document}


\maketitle



\section{Introduction}

We can define the \emph{nearest neighbor search (NSS)} problem in the following way: given a set of points $P=p_1,p_2,\dots,p_n$ in a metric space $X$, these points must be preprocessed in such a way that given a new query point $q \in X$, finding the point in $P$ that is nearest to $q$ can be done quickly.

The problem of nearest neighbor search is one of major importance in a variety of applications such as image recognition, data compression, pattern recognition and classification, machine learning,  document retrieval systems, statistics and data analysis. However, solving this problem in high dimensional spaces seems to be a very difficult task and there is no algorithm that performs significantly better than the standard brute-force search. This has lead to an increasing interest in a class of algorithms that perform approximate nearest neighbor searches, which have proven to be a good-enough approximation in most practical applications and in most cases, orders of magnitude faster that the algorithms performing the exact searches.

FLANN (Fast Approximate Nearest Neighbors) is an application/library for performing fast approximate nearest neighbor searches. FLANN is written in the D programming language (D is a C/C++ like language with a cleaner syntax, more features and just as fast as C/C++). FLANN can be used in the following ways:
\begin{itemize}
 \item As a standalone console application
\item As a library that can be included in other programs. To make this easy for C/C++ programs, a set of C bindings are provided with the library.
\item From MATLAB using a set of matlab wrappers provided with the library.
\end{itemize}


\section{Getting and compiling FLANN}

FLANN can be downloaded from the following address:
\begin{center}
\texttt{http://www.cs.ubc.ca/some/address/here}
\end{center}

After downloading and unpacking the following files and directories should be present:
\begin{itemize}
\item \texttt{Makefile}: makefile used to compile the application/library
\item \texttt{src}: directory containg the source files
\item \texttt{doc}: directory containg this documentation
\item \texttt{bin}: directory containg the gdc D compiler and build tools. Since not many system have the gdc compiler installed by default, it is distributed with the library.
\item \texttt{build}: directory where the compiled application, library, C bindings and matlab wrapper functions are stored. It has the following subdirectories:
\begin{itemize}
\item \texttt{bin}: contains the command line application (\texttt{flann})
\item \texttt{lib}: contains the compiled library (\texttt{libflann.a})
\item \texttt{include}: contains the C bindings for the library (\texttt{flann.h})
\item \texttt{matlab}: contains the MATLAB wrapper functions and a MEX (Matlab EXecutable) file
\end{itemize}



\end{itemize}

\section{Using FLANN from MATLAB}

Here is a short example of a piece of MATLAB code using the FLANN library:
\begin{Verbatim}[fontsize=\footnotesize,frame=single]

>> dataset = single(rand(128,10000));
>> testset = single(rand(128,1000));
>> result = flann_search(dataset,testset,5,struct('algorithm','kdtree','trees',4));
>> size(result)

ans =

           5        1000
\end{Verbatim}

The FLANN library can be used from MATLAB through the following wrapper functions: \texttt{flann\_build\_index}, \texttt{flann\_search} and \texttt{flann\_free\_index}. The \texttt{flann\_build\_index} function creates a search index from the dataset points, \texttt{flann\_search} uses this index to perform nearest-neighbor searches and \texttt{flann\_free\_index} deletes the index and releases the memory it uses.

The following sections describe in more detail the FLANN matlab wrapper functions, together with examples of how they may be used.

\paragraph{flann\_build\_index} 

This function creates a search index from the initial dataset of points, index later used for fast nearest-neighbor searches in the dataset.

\begin{Verbatim}
[index, parameters, speedup] = flann_build_index(dataset, precision, 
			build_time_factor, memory_factor);
\end{Verbatim}

The arguments passed to the \texttt{flann\_build\_index} function have the following meaning:
\begin{itemize}

\item \texttt{dataset} - is a $d \times n$ matrix containing $n$ $d$-dimensional points

\item \texttt{precision} - is a number between 0 and 100 specifying the percentage of the approximate nearest-neighbor searches that return the exact nearest-neighbor. Using a higher value for this parameter gives more accurate results, but the searching takes longer. The optimum value usually depends on the application.

\item \texttt{build\_time\_factor} - specifies the importance of the index build time reported to the nearest-neighbor search time. In some applications it's acceptable for the index build step to take a long time if the subsequent searches in the index can be performed very fast. In other applications it's required that the index be build as fast as possible even if that leads to slightly longer search times. (Default value: 0.1)

\item \texttt{memory\_factor} - is used to specify the tradeoff between time (index build time and search time) and memory used by the index.
\end{itemize}

This function returns the newly created \texttt{index}, the \texttt{parameters} used for creating the index and the \texttt{speedup} over linear search achieved when searching the index. The parameters are automatically estimated in such a way that the total cost (search time, index build time and used memory) is optimized. 

Because the parameter estimation step is usualy costly, it is possible to skip this step and reuse the already computed parameters the next time an index is created from similar data points (comming from the same distribution). To reuse the computed index parameters (or to specify them manually) the \texttt{flann\_build\_index} function has to be called in the following manner:


\begin{Verbatim}
index = flann_build_index(dataset,parameters);
\end{Verbatim}

 The \texttt{parameters} argument is a matlab structure containing the following parameters which are required during index creation:
\begin{itemize}
	\item \texttt{parameters.algorithm} - the algorithm to use for building the index. The possible values are: \texttt{'linear'}, \texttt{'kdtree'}, \texttt{'kmeans'} and \texttt{'composite'}. The \texttt{'linear'} option does not create any index, it uses brute-force search in the original dataset points, \texttt{'kdtree'} creates one or more randomized kd-trees, \texttt{'kmeans'} creates a hierarchical kmeans clustering tree and \texttt{'composite'} is a mix of both kdtree and kmeans trees.
	
	\item \texttt{parameters.trees} - the number of randomized kd-trees to create. This parameter is required only when the algorithm used is \texttt{'kdtree'}.
	
	\item \texttt{parameters.branching} - the branching factor to use for the hierarchical kmeans tree creation. While kdtree is always a binary tree, each node in the kmeans tree may have several branches depending on the value of this parameter. This parameter is required only when the algorithm used is \texttt{'kmeans'}.
	
	\item \texttt{params.iterations} - the maximum number of iterations to use in the kmeans clustering stage when building the kmeans tree. A value of -1 used here means that the kmeans clustering should be performed until convergence. This parameter is required only when the algorithm used is \texttt{'kmeans'}.
\end{itemize}

The above parameters have a big impact on the performance of the new search index (nearest-neighbor search time) and on the time and memory required to build the index. The optimum parameter values depend on the dataset characteristics (number of dimensions, distribution of points in the dataset) and on the application domain (desired precision for the approximate nearest neighbor searches).


\paragraph{flann\_search}

This function performs nearest-neighbor searchs using the index already created:
\begin{Verbatim}
result = flann_search(index, testset, k, parameters);
\end{Verbatim}

The arguments required by this function are:
\begin{itemize}
 \item \texttt{index}- the index returned by the \texttt{flann\_build\_index} function
 \item \texttt{testset} - a $d \times m$ matrix containing $m$ test points whose k-nearest-neighbors need to be found
 \item \texttt{k} - the number of nearest neighbors to be returned for each point from \texttt{testset}
\item \texttt{parameters} - structure containing the search parameters. Currently it has only one member, \texttt{parameters.checks}, denoting the number of times the tree(s) in the index should be recursively traversed. A higher value for this parameter would give better search precision, but also take more time. If the parameter estimation step was used when the index was created, the number of checks required to achieve the specified precision is also computed. In such case, the parameters structure returned by the \texttt{flann\_build\_index} function can be passed directly to the \texttt{flann\_search} function.
\end{itemize}

The function returns a matrix of size $k \times m$ in which each column contains the indexes (in the dataset matrix) of the $k$ nearest neighbors of the corresponding point from testset.

For the case where a single search will be performed with each index, the \texttt{flann\_search} function accepts the dataset instead of the index as first argument, in which case the index is created searched and then deleted in one step.
\begin{Verbatim}
result = flann_search(dataset, testset, k, parameters);
\end{Verbatim}


\paragraph{flann\_free\_index}

This function must be called to delete an index and release all the memory used by it.

\bigskip

Let's look at a few examples showing how the functions described above are used:

\paragraph{Example 1:}

In this example the index is constructed using automatic parameter estimation, requesting 90\% as desired precision and using the default values for the build time and memory usage factors. The index is then used to search for the nearest-neighbors of the points in the testset matrix and finally the index is deleted.

\begin{Verbatim}[fontsize=\footnotesize,frame=single]

>> dataset = single(load('dataset.dat'))';
>> size(dataset)

ans =

         128       99000

>> testset = single(load('testset.dat'))';
>> size(testset)

ans =

         128        1000

>> [index, parameters] = flann_build_index(dataset, 90);
>> parameters

parameters = 

        checks: 78
     algorithm: 'kmeans'
     branching: 56
    iterations: 3

>> result = flann_search(index,testset,5,parameters);
>> size(result)

ans =

           5        1000

>> flann_free_index(index);

\end{Verbatim}




% \bibliographystyle{alpha}
% \bibliography{references}


\paragraph{Example 2:}

In this example the index constructed with the parameters specified manually.

\begin{Verbatim}[fontsize=\footnotesize,frame=single]

>> dataset = single(load('dataset.dat'))';
>> size(dataset)

ans =

         128       99000

>> testset = single(load('testset.dat'))';
>> size(testset)

ans =

         128        1000

>> index = flann_build_index(dataset,struct('algorithm','kdtree','trees',8));

>> result = flann_search(index,testset,5,struct('checks',128));
>> size(result)

ans =

           5        1000

>> flann_free_index(index);

\end{Verbatim}

\paragraph{Example 3:}

In this example the index creation, searching and deletion are all performed in one step:

\begin{Verbatim}[fontsize=\footnotesize,frame=single]

>> dataset = single(load('dataset.dat'))';
>> size(dataset)

ans =

         128       99000

>> testset = single(load('testset.dat'))';
>> size(testset)

ans =

         128        1000

>> result = flann_search(dataset,testset,5,struct('checks',128,'algorithm','kmeans',
'branching',64,'iterations',5));
>> size(result)

ans =

           5        1000

\end{Verbatim}

\section{Using FLANN library}

A small C++ program that uses the FLANN library could look like this:

\begin{Verbatim}[fontsize=\footnotesize,frame=single]
// file flann_example.cc

#include "flann.h"
#include <stdio.h>
#include <stdlib.h>


// Function that reads a dataset of points from a file
float* read_points(char* filename, int *rows, int *cols);


int main(int argc, char** argv)
{
    int rows,cols;
    int t_rows, t_cols;

    // read dataset points from file dataset.dat
    float* dataset = read_points("dataset.dat", &rows, &cols);
    float* testset = read_points("testset.dat", &t_rows, &t_cols);

    // dataset and testset points should have the same number of dimensions
    assert(cols==t_cols);

    int nn = 3;     // number of nearest-neighbors

    // allocate memory for the nearest-neighbors 
    int* result = new int[t_rows*nn];

    nn_init();  // initialize the FLANN library

    Parameters p;   // index parameters are stored here

    // create the index
    NN_INDEX index_id = build_index(dataset, rows, cols, 90, &p);

    // compute the nearest-neighbors
    find_nearest_neighbors_index(index_id, testset, t_rows, result, nn, p.checks);

    // delete the index and free the allocated memory
    free_index(index_id);

    delete dataset;
    delete testset;
    delete result;

    return 0;
}

\end{Verbatim}

As it can be seen in the above example, FLANN can be easily used in C/C++ programs. In order todo that the library header file \texttt{flann.h} (located in the \texttt{build/include} directory) must be included. Also the compiler must be told where to look for that file, by adding the \texttt{build/include} directory to the compiler include path (all the paths in this document are specified relative to the library main directory, if the C/C++ program is located somethere else, the paths must adjusted accordingly). The directory can be added to the compiler include path using the \texttt{-I} compiler flag (on most Unix/Linux systems). When linking the C/C++ application the \texttt{libflann.a} library must be linked in. This is done using the \texttt{-l} compiler flag followed by the library name (\texttt{-lflann}) and by specifying the library search path (\texttt{build/lib}) with the \texttt{-L} flag. The command needed to compile the above example will be:
\begin{Verbatim}[fontsize=\footnotesize]
g++ flann_example.cc -I build/include -L build/lib -o flann_example -lflann
\end{Verbatim}

The following sections describe the C bindings offered by the FLANN library:

\paragraph{nn\_init}
This function performs various initializations needed by the library. It must be called once (and only once) before any other library function is called.
\begin{Verbatim}[fontsize=\footnotesize]
void nn_init();
\end{Verbatim}


\paragraph{nn\_term}
% This is the pair of nn\_init and runs finalization 
\begin{Verbatim}[fontsize=\footnotesize]
void nn_term();
\end{Verbatim}



\begin{Verbatim}[fontsize=\footnotesize]

void nn_init();

void nn_term();

NN_INDEX build_index(float* dataset, int rows, int cols, float target_precision, Parameters* parameters);

void find_nearest_neighbors(float* dataset, int rows, int cols, float* testset, int tcount, int* result, int nn, float target_precision, Parameters* parameters);

void find_nearest_neighbors_index(NN_INDEX index_id, float* testset, int tcount, int* result, int nn, int checks);

void free_index(NN_INDEX index_id);

int compute_cluster_centers(float* dataset, int rows, int cols, int clusters, float* result, Parameters* parameters);
\end{Verbatim}



\section{Using FLANN command line application}







\end{document}
