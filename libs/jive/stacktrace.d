/**
	Module for stacktracing exceptions and crashes.

   Please note that libbfd has limited success resolving symbols
   generated by DMD, but it works somewhat.

   Tracing works perfectly with GDC.
   (use -g to get line numbers)

   Principle of operation:
   
   glibc backtrace() is used for obtaining a trace of return addresses,
   it uses GCC exception handling frames when available and frame pointers
   otherwise - meaning you only need either of them for traces to work
   
   Symbolic information is found using libbfd.
   A list of object files mapped into memory is found through
   /proc/self/maps and all of them are loaded using libbfd.

   Portability: linux x86 and x86_64

   Dependencies: libbfd (included with binutils)

   Copyright: Copyright (C) 2007-2008 Zygfryd (aka Hxal). All rights reserved.
   License:   zlib
   Authors:   Zygfryd (aka Hxal)

 */

module jive.stacktrace;

import tango.stdc.stdlib : malloc, free, alloca;
import tango.stdc.stdio : FILE, fopen, fgets, fclose, sscanf;
import tango.stdc.string : strdup, strcmp;
import tango.stdc.stringz : fromUtf8z, strlenz;
import tango.core.Exception : TracedExceptionInfo, setTraceHandler;
import tango.stdc.posix.signal;
import jive.c.ucontext : ucontext_t;
import tango.stdc.posix.unistd : _exit;
import tango.core.sync.Mutex;
import tango.core.Thread : Thread;
import tango.text.convert.Format : Formatter = Format;
import tango.util.log.Trace : Trace;
import tango.stdc.posix.pthread :
	pthread_self, pthread_key_t, pthread_key_create, pthread_getspecific, pthread_setspecific;
import tango.io.FilePath;

version (GNU)
	import gcc.builtins : __builtin_return_address;

import jive.demangle : Demangler;

version (linux) {}
else { static assert (false, "Only Linux supported at the moment."); }

version (X86) {} else version (X86_64) {}
else { static assert (false, "Only x86 and x86_64 supported at the moment."); }

version (dontLink) {} else {
	version (linux) version (build) pragma (link, "bfd");
}


/** Global configuration */
public struct TraceConfig
{
	/** Maximum depth of stacktrace to obtain */
	static uint traceDepth = 64;

	/** Whether to append stacktraces to exceptions */
	static bool traceExceptions = true;

	/***************************************************************************
		Throwing exceptions on fault signals:
		this feature doesn't work very well with either DMD or GDC,
		it causes GDC to abort and DMD can leak those exceptions;
		GDC should support it once -fnon-call-exceptions or
		-fasynchronous-unwind-tables gets implemented

		When these options are disabled the handler will dump
		a stacktrace to stderr and exit
	***************************************************************************/
	static bool throwOnAccessViolation    = false;
	/** */
	static bool throwOnNumericException   = false;
	/** */
	static bool throwOnIllegalInstruction = false;
	/** */
	static void throwOnAll (bool val)
	{
		throwOnAccessViolation    = val;
		throwOnNumericException   = val;
		throwOnIllegalInstruction = val;
	}
}

/**
   Struct encapsulating a code address and symbolic information obtained
   for that address
 */
struct CodeLocation
{
	void*  address    = null;        ///
	char[] segment    = "<unknown>"; /// Segment / object file that owns this location
	char[] file       = "";          /// Name of file containing this location
	char[] subprogram = "";          /// Name of function containing this location
	uint   line       = 0;           /// Line numbers corresponding to this location

	/**
	   Output this into a static buffer.
	   
	   The format looks like:
	   address [segment] subprogram @ file:line
	 */
	char[] sprint (char[] buf)
	{
		if (file.length)
		{
			scope path = new FilePath (file);
			return Formatter.sprint (buf, PointerFormat ~ " [{1}] {2} @ {3}:{4}", address, segment, subprogram, path.file, line);
		}
		else
			return Formatter.sprint (buf, PointerFormat ~ " [{1}] {2}", address, segment, subprogram);
	}

	char[] toString () ///
	{
		char[1024] buf;
		return this.sprint (buf).dup;
	}

	/**
	   Resolve the location of calls on the current stack.

	   depth == 0 means the location where this function is called,

	   depth > 0 means that many frames should be skipped

	   Warning: It's not very fast.
	 */
	static CodeLocation findCurrent (uint depth = 0)
	{
		CodeLocation result;

		version (DigitalMars)
			void*[] buf = new void* [depth+3];
		else // this triggers an internal error in DMD
			void*[] buf = (cast(void**) alloca ((depth+3) * (void*).sizeof)) [0 .. depth+3];
		void*[] trace = getBacktrace (buf);
		void* end;
		mixin (getPC ("end"));

		synchronized (GlobalDebugInfo.mutex)
		{
			version (stacktraceDontUpdate)
			{
				GlobalDebugInfo.initialize ();
			}
			else
			{
				GlobalDebugInfo.update ();
			}

			if (trace.length > 0)
			{
				/* check if findCurrent needs to be removed from the stacktrace */
				if (trace[0] >= &findCurrent && trace[0] <= end)
				{
					if (trace.length > 1)
						GlobalDebugInfo.findLocation (trace[1], result);
				}
				else
					GlobalDebugInfo.findLocation (trace[0], result);
	
			}
		}

		return result;
	}

	/**
	   Update the debugging information, should be called after loading dynamic
	   libraries through libdl or tango.sys.SharedLib, before using findCurrent
	 */
	static void updateDebugInfo ()
	{
		synchronized (GlobalDebugInfo.mutex)
		{
			GlobalDebugInfo.update ();
		}
	}
}

/* ************************************************************************* */
private:
/* ************************************************************************* */

alias CodeLocation LocationInfo; //old name before exposing public

static if ((void*).sizeof == 4)
	const char[] PointerFormat = "0x{0:x8}";
else
	const char[] PointerFormat = "0x{0:x16}";

struct SegmentEntry
{
	char[]        name;
	bfd_vma       start;
	bfd_vma       end;
	bfd_vma       offset;
	bfd_ctx*      bfd;
	bfd_symbol**  syms;
	bfd_section*  text;
	SegmentEntry* next;
}

class DebugInfo
{
	public Mutex mutex;
	private SegmentEntry* segmentList = null;
	
	this ()
	{
		mutex = new Mutex;
	}

	void initialize ()
	{
		if (segmentList is null)
			update ();
	}

	void update ()
	{
		if (segmentList is null)
			bfd_init ();

		FILE* f = fopen ("/proc/self/maps", "r");
		char buf [1024];

		SegmentEntry* entry = segmentList;
		SegmentEntry* prev_entry = null;

		while (fgets (buf.ptr, 1024, f))
		{
			//Stdout.format ("{}", buf[0..strlenz(buf.ptr)]);
			bfd_vma start, end, offset;
			char perm [5];
			char file [1024];
			
			int n = sscanf (buf.ptr, "%llx-%llx %4s %llx %*5s %*ld %s", &start, &end, perm.ptr, &offset, file.ptr);

			if ((n == 5) && (perm[2] == 'x'))
			{
				if (strcmp (file.ptr, "[vdso]") == 0) continue;
				
				while (entry !is null && entry.start < start)
				{
					prev_entry = entry;
					entry = entry.next;
				}

				if (entry !is null)
				{
					if (entry.start == start)
					{
						//Stderr.formatln ("old entry: {} 0x{:x8}-{:x8}", entry.name, entry.start, entry.end);
						continue;
					}
					else if (entry.start > start)
					{
						auto tmp = entry;
						entry = new SegmentEntry;
						entry.next = tmp;
						if (prev_entry !is null) prev_entry.next = entry;
						else segmentList = entry;
					}
					else assert (false);
				}
				else
				{
					entry = new SegmentEntry;
					entry.next = null;
					if (prev_entry !is null) prev_entry.next = entry;
					else segmentList = entry;
				}

				{
					scope path = new FilePath (fromUtf8z (file.ptr));
					entry.name = path.file.dup;
				}

				bfd_ctx* abfd = bfd_openr (strdup (file.ptr), null);
				bfd_symbol** syms;
				
				if (!abfd)
					continue;

				if (! bfd_check_format (abfd, bfd_format.object))
				{
					bfd_close (abfd);
					continue;
				}
				
				uint storage_needed = bfd_get_symtab_upper_bound (abfd);
				syms = cast(bfd_symbol**) malloc (storage_needed);
				uint cSymbols = bfd_canonicalize_symtab (abfd, syms);
				
				bfd_section* text = bfd_get_section_by_name (abfd, ".text");
				
				if (!text)
					continue;

				entry.bfd    = abfd;
				entry.syms   = syms;
				entry.text   = text;
				entry.start  = start;
				entry.end    = end;
				entry.offset = offset;

				//Stderr.formatln ("new entry: {} 0x{:x8}-{:x8}", entry.name, entry.start, entry.end);
			}
		}

		fclose (f);
	}

	bool findLocation (void* address, out LocationInfo location)
	{
		location.segment = "<unknown>";
		location.address = address;

		version (X86)
		{
			/* force zero extension to 64-bits */
			bfd_vma addr = cast(bfd_vma) cast(uint) address;
		}
		else version (X86_64)
		{
			bfd_vma addr = cast(bfd_vma) address;
		}

		for (SegmentEntry* t = segmentList; t !is null; t = t.next)
		{
			//Stdout.formatln ("{:x8}({:x16}) in {:x16}-{:x16}", address, addr, t.start, t.end);

			if (addr > t.end)
				continue;
			
			if (addr < t.start)
				return false;
			
			location.segment = t.name;

			if (t.bfd is null || t.text is null)
				return true;
			
			bfd_vma offset;

			if (t.start > t.text.vma)
				offset = addr - t.text.vma - t.start;
			else
				offset = addr - t.text.vma;

			char* cfilename = null;
			char* cfuncname = null;
			int n = bfd_find_nearest_line (t.bfd, t.text, t.syms, offset, &cfilename, &cfuncname, &location.line);

			if ((cfilename != null && location.line > 0) || (cfilename == null && location.line == 0))
			{
				location.file = cfilename[0 .. strlenz (cfilename)];
				location.subprogram = cfuncname[0 .. strlenz (cfuncname)];

				try
				{
					scope dem = new Demangler;
					dem.expandFunctionTypes = false;
					dem.templateExpansionDepth = 1;
					dem.foldDefaults = true;

					location.subprogram = dem.demangle (location.subprogram);
				}
				catch (Exception e)
				{
					// be silent, just fail to demangle
				}
			}
			else
			{
				location.line = 0;
			}

			return n > 0;
		}
		
		return false;
	}

}

/* ************************************************************************* */

class Stacktrace : TracedExceptionInfo
{
	private void*[] trace;

	public:

	this ()
	{
		//trace.length = 8;
		//trace.length = 0;
	}

	static TracedExceptionInfo create (void* bp = null)
	{
		if (! TraceConfig.traceExceptions)
			return null;

		Stacktrace self = new Stacktrace;
		self.trace = new void* [TraceConfig.traceDepth];

		void* end;
		self.trace = getBacktrace (self.trace);

		if (self.trace.length > 0) // eliminate this function from the trace
		{
			mixin (getPC ("end"));
			if (self.trace[0] >= &create && self.trace[0] <= end)
				self.trace = self.trace[1 .. $];
		}
		
		return self;
	}

	public int opApply (int delegate (inout char[]) dg)
	{
		int result = 0;
		
		synchronized (GlobalDebugInfo.mutex)
		{
			version (stacktraceDontUpdate) {}
			else
			{
				GlobalDebugInfo.update ();
			}

			foreach (address; trace)
			{
				char[1024] buf;
				char[] msg = sprintAddress (buf, address-1);
				
				if (msg == "")
					return 0;
				
				result = dg (msg);

				if (result != 0)
					break;
			}
		}

		return result;
	}
}

/* ************************************************************************* */

private DebugInfo GlobalDebugInfo;

static this ()
{
	GlobalDebugInfo = new DebugInfo;

	version (stacktraceDontUpdate)
	{
		/* update at start, if we don't want updates while running */
		GlobalDebugInfo.update();
	}

	setTraceHandler (&Stacktrace.create);
}

/* ************************************************************************* */

class HardwareException : Exception
/* not :TracedException, because it doesn't expose m_info */
{
	private TracedExceptionInfo m_info;
	private bool confusingTrace = false;

	this (char[] msg, void* ip, void* ret_addr)
	{
		super (msg);

		Stacktrace s = new Stacktrace;
		s.trace = new void* [TraceConfig.traceDepth];

		void*[] vbuf = (cast(void**) alloca (TraceConfig.traceDepth * (void*).sizeof)) [0 .. TraceConfig.traceDepth];
		void*[] trace = getBacktrace (vbuf);
		int i = 0;

		// remove everything up to the signal handler from the trace
		while (i < trace.length && trace[i] != ret_addr) i++;

		if (i == trace.length)
		{
			// means we haven't found the signal handler on the callstack,
			// which is confusing!
			// we're dumping ip as the first element and then the trace,
			// which means it'll be non-linear, but at least informative
			s.trace = new void* [trace.length + 1];
			s.trace[0] = ip+1; //will be decremented in Stacktrace.opApply
			if (trace.length > 0)
				s.trace[1 .. $] = trace[];
		}
		else
		{
			i++;
			if (trace[i] == ip) i++;
			s.trace = new void* [trace.length - i + 1];
			s.trace[0] = ip+1; //will be decremented in Stacktrace.opApply
			s.trace[1 .. $] = trace[i .. $];
		}

		m_info = s;
	}

	this (char[] msg)
	{
		super (msg);
	}

	char[] toString ()
	{
		if (m_info is null)
			return super.toString();
		char[] buf = super.toString();
		buf ~= "\n----------------";
		foreach (line; m_info)
			buf ~= "\n" ~ line;
		return buf;
	}

	int opApply (int delegate (inout char[] buf) dg)
	{
		if (m_info is null)
			return 0;
		return m_info.opApply (dg);
	}
}

char[] messageOfSEGV (int code)
{
	version (linux)
	{
		switch (code)
		{
			case SEGV_MAPERR: return "Access violation: Access to unmapped memory";
			case SEGV_ACCERR: return "Access violation: Access to protected memory";
			default:          return "Access violation";
		}
	}
	else
	{
		return "Access violation";
	}

	return null;
}


class AccessViolation : HardwareException
{
	this (void* ip, void* ret_addr, void* addr, int code)
	{
		if (addr == null)
		{
			super ("Null pointer dereference", ip, ret_addr);
		}
		else
		{
			char[256] buf;
			super (Formatter.sprint (buf, "{} at address 0x{:x}",
				messageOfSEGV (code), addr).dup, ip, ret_addr);
		}
	}
}

char[] messageOfFPE (int code)
{
	version (linux)
	{
		switch (code)
		{
			case FPE_INTDIV: return "Numeric exception: Integer division by zero";
			case FPE_INTOVF: return "Numeric exception: Integer overflow";
			case FPE_FLTDIV: return "Numeric exception: Floating-point division by zero";
			case FPE_FLTOVF: return "Numeric exception: Floating-point overflow";
			case FPE_FLTUND: return "Numeric exception: Floating-point underflow";
			case FPE_FLTRES: return "Numeric exception: Floating-point inexact result";
			case FPE_FLTINV: return "Numeric exception: Invalid floating-point operation";
			case FPE_FLTSUB: return "Numeric exception: Subscript out of range";
			default:         return "Numeric exception: Unknown";
		}
	}
	else
	{
		return "Numeric exception";
	}

	return null;
}

class NumericException : HardwareException
{
	this (void* ip, void* ret_addr, int code)
	{
		super (messageOfFPE (code), ip, ret_addr);
	}
}

char[] messageOfILL (int code)
{
	version (linux)
	{
		switch (code)
		{
			case ILL_ILLOPC: return "Illegal instruction: Illegal opcode";
			case ILL_ILLOPN: return "Illegal instruction: Illegal operand";
			case ILL_ILLADR: return "Illegal instruction: Illegal addressing mode";
			case ILL_ILLTRP: return "Illegal instruction: Illegal trap";
			case ILL_PRVOPC: return "Illegal instruction: Privileged opcode";
			case ILL_PRVREG: return "Illegal instruction: Privileged register";
			case ILL_COPROC: return "Illegal instruction: Coprocessor error";
			case ILL_BADSTK: return "Illegal instruction: Internal stack error";
			default:         return "Illegal instruction: Unknown";
		}
	}
	else
	{
		return "Illegal instruction";
	}

	return null;
}

class IllegalInstruction : HardwareException
{
	this (void* ip, void* ret_addr, int code)
	{
		super (messageOfILL (code), ip, ret_addr);
	}
}

/* ************************************************************************* */

/* per-thread fault handling context, to avoid race conditions */
struct FaultHandlerContext
{
	int depth; /* nesting of signal handlers */

	new (uint size)
	{
		return init (malloc (size));
	}

	static void* init (void* self)
	{
		(cast(typeof(this))self).depth = 0;
		return self;
	}
}

// we use pthreads deirectly instead of ThreadLocal, so that foreign threads
// worked too
pthread_key_t ContextKey;

// purely for cosmetic reasons in sprintThread, void* for safety :P
void*         MainThreadRef;

extern(C) void jive_stacktrace_free_context (void* ctx)
{
	free (ctx);
}

static this ()
{
	pthread_key_create (&ContextKey, &jive_stacktrace_free_context);

	MainThreadRef = cast(void*) Thread.getThis();
}

version (X86)
{
	private enum
	{
		REG_EBP = 6,
		REG_EIP = 14
	}
}
else version (X86_64)
{
	private enum
	{
		REG_RBP = 10,
		REG_RIP = 16
	}
}

extern(C) void jive_stacktrace_abort_handler (int signal, siginfo_t* info, void* ctx)
{
	version (GNU)
	{
		void* ret_addr = __builtin_return_address (0);
	}
   else version (DigitalMars)
	{
		void* ret_addr;
		volatile asm { mov ret_addr, EBP; };
		ret_addr = (cast(void**)ret_addr)[1];
	}

	ucontext_t* ucontext = cast(ucontext_t*) ctx;

	version (X86)
	{
		void* ip  = cast(void*) ucontext.uc_mcontext.gregs[REG_EIP];
		//void** bp = cast(void**) ucontext.uc_mcontext.gregs[REG_EBP];
	}
	else version (X86_64)
	{
		void* ip  = cast(void*) ucontext.uc_mcontext.gregs[REG_RIP];
		//void** bp = cast(void**) ucontext.uc_mcontext.gregs[REG_RBP];
	}

	char[1024] buf;
	Trace.formatln ("Aborted in {}\n----------------", sprintThread (buf)).flush;

	synchronized (GlobalDebugInfo.mutex)
		printSignalTrace (ip, ret_addr);

	_exit (-signal);
}

extern(C) void jive_stacktrace_fault_handler (int signal, siginfo_t* info, void* ctx)
{
	Exception e;

	try
	{
		auto thread = cast(FaultHandlerContext*) pthread_getspecific (ContextKey);
		if (thread is null)
		{
			thread = new FaultHandlerContext;
			pthread_setspecific (ContextKey, thread);
		}

		thread.depth++;

		if (thread.depth > 1)
		{
			if (thread.depth == 2) //in case the following line failed
				Trace.formatln ("jive.stacktrace: signal handler interrupted ({})", signal).flush;

			uninstallHandler (signal);
			return;
		}

		version (GNU)
		{
			void* ret_addr = __builtin_return_address (0);
		}
		else version (DigitalMars)
		{
			void* ret_addr;
			volatile asm { mov ret_addr, EBP; };
			ret_addr = (cast(void**)ret_addr)[1];
		}

		ucontext_t* ucontext = cast(ucontext_t*) ctx;

		version (X86)
		{
			void* ip  = cast(void*) ucontext.uc_mcontext.gregs[REG_EIP];
			//void** bp = cast(void**) ucontext.uc_mcontext.gregs[REG_EBP];
		}
		else version (X86_64)
		{
			void* ip  = cast(void*) ucontext.uc_mcontext.gregs[REG_RIP];
			//void** bp = cast(void**) ucontext.uc_mcontext.gregs[REG_RBP];
		}

		char[1024] buf;

		switch (signal)
		{
			case SIGSEGV:
				void* addr = info._sifields._sigfault.si_addr;

				if (!TraceConfig.throwOnAccessViolation)
				{
					if (addr == null)
						Trace.formatln ("\nIn {}: Null pointer dereference\n----------------",
							sprintThread (buf)).flush;
					else
						Trace.formatln ("\nIn {}: {} at address 0x{:x}\n----------------",
							sprintThread (buf), messageOfSEGV (info.si_code), addr).flush;

					synchronized (GlobalDebugInfo.mutex)
						printSignalTrace (ip, ret_addr);

					_exit (-signal);
				}

				e = new AccessViolation (ip, ret_addr, addr, info.si_code);
				break;

			case SIGFPE:

				if (!TraceConfig.throwOnNumericException)
				{
					Trace.formatln ("\nIn {}: {}\n----------------", sprintThread (buf),
						messageOfFPE (info.si_code)).flush;

					synchronized (GlobalDebugInfo.mutex)
						printSignalTrace (ip, ret_addr);

					_exit (-signal);
				}

				e = new NumericException (ip, ret_addr, info.si_code);
				break;
			
			case SIGILL:
			
				if (!TraceConfig.throwOnIllegalInstruction)
				{
					Trace.formatln ("\nIn {}: {}\n----------------", sprintThread (buf),
						messageOfILL (info.si_code)).flush;

					synchronized (GlobalDebugInfo.mutex)
						printSignalTrace (ip, ret_addr);

					_exit (-signal);
				}

				e = new IllegalInstruction (ip, ret_addr, info.si_code);
				break;

			default:
				return;
		}

		//installFaultHandler (signal);

		thread.depth--;
	}
	catch (Exception error)
	{
		abort ();
	}

	throw e;
}

/* ************************************************************************* */

static this ()
{
	installAbortHandler (SIGABRT);
	
	installFaultHandler (SIGSEGV);
	installFaultHandler (SIGFPE);
	installFaultHandler (SIGILL);
}

void installFaultHandler (int signal)
{
	static sigaction_t sa;
	sa.sa_sigaction = &jive_stacktrace_fault_handler;
	sa.sa_flags |= SA_SIGINFO | SA_NODEFER;
	sigaction (signal, &sa, null);
}

void installAbortHandler (int signal)
{
	static sigaction_t sa;
	sa.sa_sigaction = &jive_stacktrace_abort_handler;
	sa.sa_flags |= SA_SIGINFO | SA_RESETHAND | SA_NODEFER;
	sigaction (signal, &sa, null);
}

void uninstallHandler (int signal)
{
	static sigaction_t sa;
	sa.sa_sigaction = cast(sigactfn_t) SIG_DFL;
	sa.sa_flags |= SA_SIGINFO | SA_NODEFER;
	sigaction (signal, &sa, null);
}

/* ************************************************************************* */

char[] sprintThread (char[] buf)
{
	Thread self = Thread.getThis();
	if (self !is null)
	{
		if (cast(void*) self == MainThreadRef)
		{
			return "main thread";
		}
		else if (self.name != "")
		{
			return self.name;
		}
		else
		{
			return Formatter.sprint (buf, "thread 0x{:x}", cast(void*) self);
		}
	}
	else
	{
		return Formatter.sprint (buf, "foreign thread 0x{:x}", pthread_self());
	}
}

char[] sprintAddress (char[] buf, void* address)
{
	LocationInfo location;

	bool found = GlobalDebugInfo.findLocation (address, location);

	return location.sprint (buf);
}

void printAddress (void* address)
{
	char[4096] buf;
	Trace.formatln ("{}", sprintAddress (buf, address)).flush;
}

void*[] getBacktrace (void*[] buf = null)
{
	if (buf.length == 0)
		buf = new void* [TraceConfig.traceDepth];

	int amt = backtrace (buf.ptr, buf.length);

	if (amt <= 0) return null;

	void* end;
	mixin (getPC ("end"));

	if (buf[0] >= &getBacktrace && buf[0] <= end)
		return buf[1 .. amt];
	
	return buf[0 .. amt];
}

void printSignalTrace (void* ip, void* ret_addr)
{
	version (stacktraceDontUpdate) {}
	else
	{
		GlobalDebugInfo.update ();
	}

	void*[] vbuf = (cast(void**) alloca (TraceConfig.traceDepth * (void*).sizeof)) [0 .. TraceConfig.traceDepth];
	void*[] trace = getBacktrace (vbuf);
	int i = 0;

	while (i < trace.length && trace[i] != ret_addr) i++;

	// remove everything up to the signal handler from the trace
	if (i == trace.length)
	{
		// see HardwareException.this for an explanation
		if (trace.length > 0)
			Trace.formatln ("Couldn't locate signal handler address in trace").flush;
		printAddress (ip);
		if (trace.length > 0)
		{
			Trace.formatln ("Unprocessed trace:").flush;
			foreach (address; trace)
				printAddress (address);
		}
	}
	else
	{
		i++;
		if (trace[i] == ip) i++;
		printAddress (ip);
		while (i < trace.length)
		{
			printAddress (trace[i]-1);
			i++;
		}
	}
	return;
}

private char[] getPC (char[] var) // mixin
{
	version (X86)
	{
		return `
		volatile asm
		{
			call L;
		L:	pop EBX;
			mov ` ~ var ~ `, EBX;
		}`;
	}
	else version (X86_64)
	{
		return `
		volatile asm
		{
			"call 1f";
			"1: pop %%rax";
			"mov %%rax, %0" : "=r" ` ~ var ~ `;
		}`;
	}
}

/* ************************************************************************* */

private extern (C)
{
	// glibc

	extern(C) int backtrace (void** buf, int size);
	extern(C) void abort ();

	// libbfd

	alias ulong bfd_vma;

	enum bfd_format
	{
		unknown, object, archive, core
	}

	void bfd_init ();
	bfd_ctx* bfd_openr (char*, char*);
	bool bfd_check_format (bfd_ctx*, bfd_format);
	bfd_section* bfd_get_section_by_name (bfd_ctx*, char* name);
	void bfd_close (bfd_ctx* bfd);

	alias int bfd_boolean;
	alias long file_ptr;
	alias ulong ufile_ptr;
	alias uint flagword;
	enum bfd_direction { no, read, write, both };

	int bfd_get_symtab_upper_bound (bfd_ctx* bfd) { return bfd.xvec._bfd_get_symtab_upper_bound (bfd); }
	int bfd_canonicalize_symtab (bfd_ctx* bfd, bfd_symbol** sym) { return bfd.xvec._bfd_canonicalize_symtab (bfd, sym); }
	int bfd_find_nearest_line (bfd_ctx* bfd, bfd_section* section, bfd_symbol** sym, ulong x, char** y, char** z, uint* t)
	{
		return bfd.xvec._bfd_find_nearest_line (bfd, section, sym, x, y, z, t);
	}

	version (X86)
	{
		align (4):

		struct bfd_ctx
		{
			uint id;
			char *filename;
			bfd_target *xvec;
			void *iostream;
			void* iovec; //bfd_iovec *iovec;
			bfd_boolean cacheable;
			bfd_boolean target_defaulted;
			bfd_ctx *lru_prev;
			bfd_ctx *lru_next;
			ufile_ptr where;
			bfd_boolean opened_once;
			bfd_boolean mtime_set;
			int mtime;
			int ifd;
			bfd_format format;
			bfd_direction direction;
			flagword flags;
			ufile_ptr origin;
			bfd_boolean output_has_begun;
			bfd_hash_table section_htab;
			bfd_section *sections;
			bfd_section *section_last;
			uint section_count;
			bfd_vma start_address;
			uint symcount;
			bfd_symbol **outsymbols;
			uint dynsymcount;
			void* arch_info; //bfd_arch_info *arch_info;
			bfd_boolean no_export;
			void *arelt_data;
			bfd_ctx *my_archive;
			bfd_ctx *next;
			bfd_ctx *archive_head;
			bfd_boolean has_armap;
			bfd_ctx *link_next;
			int archive_pass;
			//_N5 tdata;
			//void *usrdata;
			//void *memory;
		}

		struct bfd_hash_table
		{
			void* dummy0; //bfd_hash_entry **table;
			uint size;
			uint entsize;
			void* dummy1; //bfd_hash_entry * function(bfd_hash_entry *, bfd_hash_table *, char *)newfunc;
			void *memory;
		}

		struct bfd_target
		{
			char *name;
			int flavour;
			int byteorder;
			int header_byteorder;
			flagword object_flags;
			flagword section_flags;
			char symbol_leading_char;
			char ar_pad_char;
			ushort ar_max_namelen;
			ulong  function(void *)bfd_getx64;
			long  function(void *)bfd_getx_signed_64;
			void  function(ulong , void *)bfd_putx64;
			ulong  function(void *)bfd_getx32;
			long  function(void *)bfd_getx_signed_32;
			void  function(ulong , void *)bfd_putx32;
			ulong  function(void *)bfd_getx16;
			long  function(void *)bfd_getx_signed_16;
			void  function(ulong , void *)bfd_putx16;
			ulong  function(void *)bfd_h_getx64;
			long  function(void *)bfd_h_getx_signed_64;
			void  function(ulong , void *)bfd_h_putx64;
			ulong  function(void *)bfd_h_getx32;
			long  function(void *)bfd_h_getx_signed_32;
			void  function(ulong , void *)bfd_h_putx32;
			ulong  function(void *)bfd_h_getx16;
			long  function(void *)bfd_h_getx_signed_16;
			void  function(ulong , void *)bfd_h_putx16;
			bfd_target * function(bfd_ctx*)[4]_bfd_check_format;
			int  function(bfd_ctx*)[4]_bfd_set_format;
			int  function(bfd_ctx*)[4]_bfd_write_contents;
			int  function(bfd_ctx*)_close_and_cleanup;
			int  function(bfd_ctx*)_bfd_free_cached_info;
			int  function(bfd_ctx*, bfd_section *)_new_section_hook;
			int  function(bfd_ctx*, bfd_section *, void *, long , ulong )_bfd_get_section_contents;
			void* dummy1; //int  function(bfd_ctx*, bfd_section *, _bfd_window *, long , ulong )_bfd_get_section_contents_in_window;
			int  function(bfd_ctx*, bfd_ctx*)_bfd_copy_private_bfd_data;
			int  function(bfd_ctx*, bfd_ctx*)_bfd_merge_private_bfd_data;
			void* dummy2; //int  function(bfd_ctx*, bfd_section *, bfd_ctx*, bfd_section *, bfd_link_info *)_bfd_init_private_section_data;
			int  function(bfd_ctx*, bfd_section *, bfd_ctx*, bfd_section *)_bfd_copy_private_section_data;
			int  function(bfd_ctx*, bfd_symbol *, bfd_ctx*, bfd_symbol *)_bfd_copy_private_symbol_data;
			int  function(bfd_ctx*, bfd_ctx*)_bfd_copy_private_header_data;
			int  function(bfd_ctx*, uint )_bfd_set_private_flags;
			int  function(bfd_ctx*, void *)_bfd_print_private_bfd_data;
			char * function(bfd_ctx*)_core_file_failing_command;
			int  function(bfd_ctx*)_core_file_failing_signal;
			int  function(bfd_ctx*, bfd_ctx*)_core_file_matches_executable_p;
			int  function(bfd_ctx*)_bfd_slurp_armap;
			int  function(bfd_ctx*)_bfd_slurp_extended_name_table;
			int  function(bfd_ctx*, char **, ulong *, char **)_bfd_construct_extended_name_table;
			void  function(bfd_ctx*, char *, char *)_bfd_truncate_arname;
			void* dummy3; //int  function(bfd_ctx*, uint , orl *, uint , int )write_armap;
			void * function(bfd_ctx*)_bfd_read_ar_hdr_fn;
			bfd_ctx* function(bfd_ctx*, bfd_ctx*)openr_next_archived_file;
			bfd_ctx* function(bfd_ctx*, uint )_bfd_get_elt_at_index;
			void* dummy4; //int  function(bfd_ctx*, stat *)_bfd_stat_arch_elt;
			int  function(bfd_ctx*)_bfd_update_armap_timestamp;
			int  function(bfd_ctx*)_bfd_get_symtab_upper_bound;
			int  function(bfd_ctx*, bfd_symbol **)_bfd_canonicalize_symtab;
			bfd_symbol * function(bfd_ctx*)_bfd_make_empty_symbol;
			void  function(bfd_ctx*, void *, bfd_symbol *, int )_bfd_print_symbol;
			void* dummy5; // void  function(bfd_ctx*, bfd_symbol *, _symbol_info *)_bfd_get_symbol_info;
			int  function(bfd_ctx*, char *)_bfd_is_local_label_name;
			int  function(bfd_ctx*, bfd_symbol *)_bfd_is_target_special_symbol;
			void* dummy6; //lineno_cache_entry * function(bfd_ctx*, bfd_symbol *)_get_lineno;
			int  function(bfd_ctx*, bfd_section *, bfd_symbol **, ulong , char **, char **, uint *)_bfd_find_nearest_line;
			int  function(bfd_ctx*, bfd_symbol **, bfd_symbol *, char **, uint *)_bfd_find_line;
			int  function(bfd_ctx*, char **, char **, uint *)_bfd_find_inliner_info;
			bfd_symbol * function(bfd_ctx*, void *, uint size)_bfd_make_debug_symbol;
			int  function(bfd_ctx*, int , void **, uint *)_read_minisymbols;
			bfd_symbol * function(bfd_ctx*, int , void *, bfd_symbol *)_minisymbol_to_symbol;
			int  function(bfd_ctx*, bfd_section *)_get_reloc_upper_bound;
			void* dummy7; //int  function(bfd_ctx*, bfd_section *, reloc_cache_entry **, bfd_symbol **)_bfd_canonicalize_reloc;
			void* dummy8; //reloc_howto_struct * function(bfd_ctx*, int )reloc_type_lookup;
			int  function(bfd_ctx*, int , uint )_bfd_set_arch_mach;
			int  function(bfd_ctx*, bfd_section *, void *, long , ulong )_bfd_set_section_contents;
			int  function(bfd_ctx*, int )_bfd_sizeof_headers;
			void* dummy9; //ubyte * function(bfd_ctx*, bfd_link_info *, bfd_link_order *, ubyte *, int , bfd_symbol **)_bfd_get_relocated_section_contents;
			void* dummy10; //int  function(bfd_ctx*, bfd_section *, bfd_link_info *, int *)_bfd_relax_section;
			void* dummy11; //bfd_link_hash_table * function(bfd_ctx*)_bfd_link_hash_table_create;
			void* dummy12; //void  function(bfd_link_hash_table *)_bfd_link_hash_table_free;
			void* dummy13; //int  function(bfd_ctx*, bfd_link_info *)_bfd_link_add_symbols;
			void* dummy14; //void  function(bfd_section *, bfd_link_info *)_bfd_link_just_syms;
			void* dummy15; //int  function(bfd_ctx*, bfd_link_info *)_bfd_final_link;
			int  function(bfd_ctx*, bfd_section *)_bfd_link_split_section;
			void* dummy16; //int  function(bfd_ctx*, bfd_link_info *)_bfd_gc_sections;
			void* dummy17; //int  function(bfd_ctx*, bfd_link_info *)_bfd_merge_sections;
			int  function(bfd_ctx*, bfd_section *)_bfd_is_group_section;
			int  function(bfd_ctx*, bfd_section *)_bfd_discard_group;
			void  function(bfd_ctx*, bfd_section *)_section_already_linked;
			int  function(bfd_ctx*)_bfd_get_dynamic_symtab_upper_bound;
			int  function(bfd_ctx*, bfd_symbol **)_bfd_canonicalize_dynamic_symtab;
			int  function(bfd_ctx*, int , bfd_symbol **, int , bfd_symbol **, bfd_symbol **)_bfd_get_synthetic_symtab;
			int  function(bfd_ctx*)_bfd_get_dynamic_reloc_upper_bound;
			void* dummy18; //int  function(bfd_ctx*, reloc_cache_entry **, bfd_symbol **)_bfd_canonicalize_dynamic_reloc;
			bfd_target *alternative_target;
			void *backend_data;
		}

		struct bfd_section
		{
			char *name;
			int id;
			int index;
			bfd_section *next;
			bfd_section *prev;
			flagword flags;
			uint __bitfield1;
/+			uint user_set_vma() { return (__bitfield1 >> 0) & 0x1; }
			uint user_set_vma(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffffe) | (value << 0); return value; }
			uint linker_mark() { return (__bitfield1 >> 1) & 0x1; }
			uint linker_mark(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffffd) | (value << 1); return value; }
			uint linker_has_input() { return (__bitfield1 >> 2) & 0x1; }
			uint linker_has_input(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffffb) | (value << 2); return value; }
			uint gc_mark() { return (__bitfield1 >> 3) & 0x1; }
			uint gc_mark(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffff7) | (value << 3); return value; }
			uint gc_mark_from_eh() { return (__bitfield1 >> 4) & 0x1; }
			uint gc_mark_from_eh(uint value) { __bitfield1 = (__bitfield1 & 0xffffffffffffffef) | (value << 4); return value; }
			uint segment_mark() { return (__bitfield1 >> 5) & 0x1; }
			uint segment_mark(uint value) { __bitfield1 = (__bitfield1 & 0xffffffffffffffdf) | (value << 5); return value; }
			uint sec_info_type() { return (__bitfield1 >> 6) & 0x7; }
			uint sec_info_type(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffe3f) | (value << 6); return value; }
			uint use_rela_p() { return (__bitfield1 >> 9) & 0x1; }
			uint use_rela_p(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffdff) | (value << 9); return value; }
			uint has_tls_reloc() { return (__bitfield1 >> 10) & 0x1; }
			uint has_tls_reloc(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffbff) | (value << 10); return value; }
			uint has_gp_reloc() { return (__bitfield1 >> 11) & 0x1; }
			uint has_gp_reloc(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffff7ff) | (value << 11); return value; }
			uint need_finalize_relax() { return (__bitfield1 >> 12) & 0x1; }
			uint need_finalize_relax(uint value) { __bitfield1 = (__bitfield1 & 0xffffffffffffefff) | (value << 12); return value; }
			uint reloc_done() { return (__bitfield1 >> 13) & 0x1; }
			uint reloc_done(uint value) { __bitfield1 = (__bitfield1 & 0xffffffffffffdfff) | (value << 13); return value; }+/
			bfd_vma vma;
			bfd_vma lma;
			bfd_vma size;
			bfd_vma rawsize;
			bfd_vma output_offset;
	/+		bfd_section *output_section;
			uint alignment_power;
			reloc_cache_entry *relocation;
			reloc_cache_entry **orelocation;
			uint reloc_count;
			long filepos;
			long rel_filepos;
			long line_filepos;
			void *userdata;
			ubyte *contents;
			lineno_cache_entry *lineno;
			uint lineno_count;
			uint entsize;
			bfd_section *kept_section;
			long moving_line_filepos;
			int target_index;
			void *used_by_bfd;
			relent_chain *constructor_chain;
			bfd *owner;
			bfd_symbol *symbol;
			bfd_symbol **symbol_ptr_ptr;
			_N3 map_head;
			_N3 map_tail;+/
		}

		struct bfd_symbol
		{
			bfd_ctx *the_bfd;
			char *name;
			ulong value;
			uint flags;
			bfd_section *section;
			//_N4 udata;
		}
	}
	else
	{
		// copy pasta from above, just without align(4)

		struct bfd_ctx
		{
			uint id;
			char *filename;
			bfd_target *xvec;
			void *iostream;
			void* iovec; //bfd_iovec *iovec;
			bfd_boolean cacheable;
			bfd_boolean target_defaulted;
			bfd_ctx *lru_prev;
			bfd_ctx *lru_next;
			ufile_ptr where;
			bfd_boolean opened_once;
			bfd_boolean mtime_set;
			int mtime;
			int ifd;
			bfd_format format;
			bfd_direction direction;
			flagword flags;
			ufile_ptr origin;
			bfd_boolean output_has_begun;
			bfd_hash_table section_htab;
			bfd_section *sections;
			bfd_section *section_last;
			uint section_count;
			bfd_vma start_address;
			uint symcount;
			bfd_symbol **outsymbols;
			uint dynsymcount;
			void* arch_info; //bfd_arch_info *arch_info;
			bfd_boolean no_export;
			void *arelt_data;
			bfd_ctx *my_archive;
			bfd_ctx *next;
			bfd_ctx *archive_head;
			bfd_boolean has_armap;
			bfd_ctx *link_next;
			int archive_pass;
			//_N5 tdata;
			//void *usrdata;
			//void *memory;
		}

		struct bfd_hash_table
		{
			void* dummy0; //bfd_hash_entry **table;
			uint size;
			uint entsize;
			void* dummy1; //bfd_hash_entry * function(bfd_hash_entry *, bfd_hash_table *, char *)newfunc;
			void *memory;
		}

		struct bfd_target
		{
			char *name;
			int flavour;
			int byteorder;
			int header_byteorder;
			flagword object_flags;
			flagword section_flags;
			char symbol_leading_char;
			char ar_pad_char;
			ushort ar_max_namelen;
			ulong  function(void *)bfd_getx64;
			long  function(void *)bfd_getx_signed_64;
			void  function(ulong , void *)bfd_putx64;
			ulong  function(void *)bfd_getx32;
			long  function(void *)bfd_getx_signed_32;
			void  function(ulong , void *)bfd_putx32;
			ulong  function(void *)bfd_getx16;
			long  function(void *)bfd_getx_signed_16;
			void  function(ulong , void *)bfd_putx16;
			ulong  function(void *)bfd_h_getx64;
			long  function(void *)bfd_h_getx_signed_64;
			void  function(ulong , void *)bfd_h_putx64;
			ulong  function(void *)bfd_h_getx32;
			long  function(void *)bfd_h_getx_signed_32;
			void  function(ulong , void *)bfd_h_putx32;
			ulong  function(void *)bfd_h_getx16;
			long  function(void *)bfd_h_getx_signed_16;
			void  function(ulong , void *)bfd_h_putx16;
			bfd_target * function(bfd_ctx*)[4]_bfd_check_format;
			int  function(bfd_ctx*)[4]_bfd_set_format;
			int  function(bfd_ctx*)[4]_bfd_write_contents;
			int  function(bfd_ctx*)_close_and_cleanup;
			int  function(bfd_ctx*)_bfd_free_cached_info;
			int  function(bfd_ctx*, bfd_section *)_new_section_hook;
			int  function(bfd_ctx*, bfd_section *, void *, long , ulong )_bfd_get_section_contents;
			void* dummy1; //int  function(bfd_ctx*, bfd_section *, _bfd_window *, long , ulong )_bfd_get_section_contents_in_window;
			int  function(bfd_ctx*, bfd_ctx*)_bfd_copy_private_bfd_data;
			int  function(bfd_ctx*, bfd_ctx*)_bfd_merge_private_bfd_data;
			void* dummy2; //int  function(bfd_ctx*, bfd_section *, bfd_ctx*, bfd_section *, bfd_link_info *)_bfd_init_private_section_data;
			int  function(bfd_ctx*, bfd_section *, bfd_ctx*, bfd_section *)_bfd_copy_private_section_data;
			int  function(bfd_ctx*, bfd_symbol *, bfd_ctx*, bfd_symbol *)_bfd_copy_private_symbol_data;
			int  function(bfd_ctx*, bfd_ctx*)_bfd_copy_private_header_data;
			int  function(bfd_ctx*, uint )_bfd_set_private_flags;
			int  function(bfd_ctx*, void *)_bfd_print_private_bfd_data;
			char * function(bfd_ctx*)_core_file_failing_command;
			int  function(bfd_ctx*)_core_file_failing_signal;
			int  function(bfd_ctx*, bfd_ctx*)_core_file_matches_executable_p;
			int  function(bfd_ctx*)_bfd_slurp_armap;
			int  function(bfd_ctx*)_bfd_slurp_extended_name_table;
			int  function(bfd_ctx*, char **, ulong *, char **)_bfd_construct_extended_name_table;
			void  function(bfd_ctx*, char *, char *)_bfd_truncate_arname;
			void* dummy3; //int  function(bfd_ctx*, uint , orl *, uint , int )write_armap;
			void * function(bfd_ctx*)_bfd_read_ar_hdr_fn;
			bfd_ctx* function(bfd_ctx*, bfd_ctx*)openr_next_archived_file;
			bfd_ctx* function(bfd_ctx*, uint )_bfd_get_elt_at_index;
			void* dummy4; //int  function(bfd_ctx*, stat *)_bfd_stat_arch_elt;
			int  function(bfd_ctx*)_bfd_update_armap_timestamp;
			int  function(bfd_ctx*)_bfd_get_symtab_upper_bound;
			int  function(bfd_ctx*, bfd_symbol **)_bfd_canonicalize_symtab;
			bfd_symbol * function(bfd_ctx*)_bfd_make_empty_symbol;
			void  function(bfd_ctx*, void *, bfd_symbol *, int )_bfd_print_symbol;
			void* dummy5; // void  function(bfd_ctx*, bfd_symbol *, _symbol_info *)_bfd_get_symbol_info;
			int  function(bfd_ctx*, char *)_bfd_is_local_label_name;
			int  function(bfd_ctx*, bfd_symbol *)_bfd_is_target_special_symbol;
			void* dummy6; //lineno_cache_entry * function(bfd_ctx*, bfd_symbol *)_get_lineno;
			int  function(bfd_ctx*, bfd_section *, bfd_symbol **, ulong , char **, char **, uint *)_bfd_find_nearest_line;
			int  function(bfd_ctx*, bfd_symbol **, bfd_symbol *, char **, uint *)_bfd_find_line;
			int  function(bfd_ctx*, char **, char **, uint *)_bfd_find_inliner_info;
			bfd_symbol * function(bfd_ctx*, void *, uint size)_bfd_make_debug_symbol;
			int  function(bfd_ctx*, int , void **, uint *)_read_minisymbols;
			bfd_symbol * function(bfd_ctx*, int , void *, bfd_symbol *)_minisymbol_to_symbol;
			int  function(bfd_ctx*, bfd_section *)_get_reloc_upper_bound;
			void* dummy7; //int  function(bfd_ctx*, bfd_section *, reloc_cache_entry **, bfd_symbol **)_bfd_canonicalize_reloc;
			void* dummy8; //reloc_howto_struct * function(bfd_ctx*, int )reloc_type_lookup;
			int  function(bfd_ctx*, int , uint )_bfd_set_arch_mach;
			int  function(bfd_ctx*, bfd_section *, void *, long , ulong )_bfd_set_section_contents;
			int  function(bfd_ctx*, int )_bfd_sizeof_headers;
			void* dummy9; //ubyte * function(bfd_ctx*, bfd_link_info *, bfd_link_order *, ubyte *, int , bfd_symbol **)_bfd_get_relocated_section_contents;
			void* dummy10; //int  function(bfd_ctx*, bfd_section *, bfd_link_info *, int *)_bfd_relax_section;
			void* dummy11; //bfd_link_hash_table * function(bfd_ctx*)_bfd_link_hash_table_create;
			void* dummy12; //void  function(bfd_link_hash_table *)_bfd_link_hash_table_free;
			void* dummy13; //int  function(bfd_ctx*, bfd_link_info *)_bfd_link_add_symbols;
			void* dummy14; //void  function(bfd_section *, bfd_link_info *)_bfd_link_just_syms;
			void* dummy15; //int  function(bfd_ctx*, bfd_link_info *)_bfd_final_link;
			int  function(bfd_ctx*, bfd_section *)_bfd_link_split_section;
			void* dummy16; //int  function(bfd_ctx*, bfd_link_info *)_bfd_gc_sections;
			void* dummy17; //int  function(bfd_ctx*, bfd_link_info *)_bfd_merge_sections;
			int  function(bfd_ctx*, bfd_section *)_bfd_is_group_section;
			int  function(bfd_ctx*, bfd_section *)_bfd_discard_group;
			void  function(bfd_ctx*, bfd_section *)_section_already_linked;
			int  function(bfd_ctx*)_bfd_get_dynamic_symtab_upper_bound;
			int  function(bfd_ctx*, bfd_symbol **)_bfd_canonicalize_dynamic_symtab;
			int  function(bfd_ctx*, int , bfd_symbol **, int , bfd_symbol **, bfd_symbol **)_bfd_get_synthetic_symtab;
			int  function(bfd_ctx*)_bfd_get_dynamic_reloc_upper_bound;
			void* dummy18; //int  function(bfd_ctx*, reloc_cache_entry **, bfd_symbol **)_bfd_canonicalize_dynamic_reloc;
			bfd_target *alternative_target;
			void *backend_data;
		}

		struct bfd_section
		{
			char *name;
			int id;
			int index;
			bfd_section *next;
			bfd_section *prev;
			flagword flags;
			uint __bitfield1;
/+			uint user_set_vma() { return (__bitfield1 >> 0) & 0x1; }
			uint user_set_vma(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffffe) | (value << 0); return value; }
			uint linker_mark() { return (__bitfield1 >> 1) & 0x1; }
			uint linker_mark(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffffd) | (value << 1); return value; }
			uint linker_has_input() { return (__bitfield1 >> 2) & 0x1; }
			uint linker_has_input(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffffb) | (value << 2); return value; }
			uint gc_mark() { return (__bitfield1 >> 3) & 0x1; }
			uint gc_mark(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffff7) | (value << 3); return value; }
			uint gc_mark_from_eh() { return (__bitfield1 >> 4) & 0x1; }
			uint gc_mark_from_eh(uint value) { __bitfield1 = (__bitfield1 & 0xffffffffffffffef) | (value << 4); return value; }
			uint segment_mark() { return (__bitfield1 >> 5) & 0x1; }
			uint segment_mark(uint value) { __bitfield1 = (__bitfield1 & 0xffffffffffffffdf) | (value << 5); return value; }
			uint sec_info_type() { return (__bitfield1 >> 6) & 0x7; }
			uint sec_info_type(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffe3f) | (value << 6); return value; }
			uint use_rela_p() { return (__bitfield1 >> 9) & 0x1; }
			uint use_rela_p(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffdff) | (value << 9); return value; }
			uint has_tls_reloc() { return (__bitfield1 >> 10) & 0x1; }
			uint has_tls_reloc(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffffbff) | (value << 10); return value; }
			uint has_gp_reloc() { return (__bitfield1 >> 11) & 0x1; }
			uint has_gp_reloc(uint value) { __bitfield1 = (__bitfield1 & 0xfffffffffffff7ff) | (value << 11); return value; }
			uint need_finalize_relax() { return (__bitfield1 >> 12) & 0x1; }
			uint need_finalize_relax(uint value) { __bitfield1 = (__bitfield1 & 0xffffffffffffefff) | (value << 12); return value; }
			uint reloc_done() { return (__bitfield1 >> 13) & 0x1; }
			uint reloc_done(uint value) { __bitfield1 = (__bitfield1 & 0xffffffffffffdfff) | (value << 13); return value; }+/
			bfd_vma vma;
			bfd_vma lma;
			bfd_vma size;
			bfd_vma rawsize;
			bfd_vma output_offset;
	/+		bfd_section *output_section;
			uint alignment_power;
			reloc_cache_entry *relocation;
			reloc_cache_entry **orelocation;
			uint reloc_count;
			long filepos;
			long rel_filepos;
			long line_filepos;
			void *userdata;
			ubyte *contents;
			lineno_cache_entry *lineno;
			uint lineno_count;
			uint entsize;
			bfd_section *kept_section;
			long moving_line_filepos;
			int target_index;
			void *used_by_bfd;
			relent_chain *constructor_chain;
			bfd *owner;
			bfd_symbol *symbol;
			bfd_symbol **symbol_ptr_ptr;
			_N3 map_head;
			_N3 map_tail;+/
		}

		struct bfd_symbol
		{
			bfd_ctx *the_bfd;
			char *name;
			ulong value;
			uint flags;
			bfd_section *section;
			//_N4 udata;
		}
	}
}

