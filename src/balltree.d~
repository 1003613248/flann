
import util;
import kdtree;

class AgglomerativeTree {

	/++
	+/
	struct NodeSt {
		int kd_ind;
		
		float* point; // center of this node
		float variance; // the variance of the points in the node
		int size;  // number of points in the node. Should be child1.size + child2.size
		
		TreeNode child1;
		TreeNode child2;	
	};
	alias NodeSt* TreeNode;

	const int NUM_KDTREES = 4;
	const int KD_MAXCHECK = 8;
	const float SIM_THRESHOLD = 20.0;

	KDTree kdtree;
	
	TreeNode[] chain;
	float[] sim;
	TreeNode[] nodes;  // vector of nodes to agglomerate
	int[] rmap; 	// mapping from kd_indices to nodes vector
	int pcount;
	
	Pool pool;
	
	int veclen;
	

	public this(float **vecs, int vcount, int veclen)
	{
		kdtree = new KDTree(vecs,vcount,veclen, NUM_KDTREES);
		
		pool = kdtree.pool;
		
		this.chain = new TreeNode[vcount];
		this.sim = new float[vcount];
		
		this.nodes = new TreeNode[vcount];
		this.rmap = new int[vcount];
		for (int i=0;i<vcount;++i) {
			nodes[i] = new NodeSt();
			nodes[i].kd_ind = i;
			nodes[i].point = vecs[i];
			nodes[i].variance = 0.0;
			nodes[i].child1 = nodes[i].child2 = null;
			nodes[i].size = 1;
			
			rmap[i] = i;
		}
		
		this.veclen = veclen;
		this.pcount = vcount;
		
		constructTree();
	}
	
	
	private TreeNode selectRandomPoint() 
	{
	 	int rand = cast(int) (drand48() * pcount);  
		assert(rand >=0 && rand < pcount);
		
		return nodes[rand];
	}
	
	private void removePoint(TreeNode v) 
	{
		kdtree.RemoveElement(v.kd_ind);
			
		nodes[rmap[v.kd_ind]] = nodes[pcount-1];
		pcount--;
		
		rmap[v.kd_ind] = -1;
	}
	
	private float similarity(TreeNode n1, TreeNode n2) 
	{
	
		float result = n1.variance + 
							n2.variance +
							kdtree.DistSquared(n1.point,n2.point,veclen);
							
		return result;							
	}
	
	private int agglomerateAdd(TreeNode node1, TreeNode node2) 
	{		
		int n = node1.size;
		int m = node2.size;
		
		TreeNode bt_new = new NodeSt();
		
		bt_new.point = pool.malloc!(float)(veclen);
		for (int i=0;i<veclen;++i) {
			bt_new.size = n + m;
			bt_new.point[i] = (n*node1.point[i]+m*node2.point[i])/bt_new.size;
		}
		
		float dist = kdtree.DistSquared(node1.point, node2.point, veclen);
		bt_new.variance = (n*node1.variance+m*node2.variance+ (n*m*dist)/(n+m))/(n+m);
		
		bt_new.child1 = node1;
		bt_new.child2 = node2;
		
		// add node to kdtree
		bt_new.kd_ind = kdtree.InsertElement(bt_new.point);
		
		// add node to nodes array
		nodes[pcount++] = bt_new;
		
		// add to reverse mapping
		if (bt_new.kd_ind>=rmap.length) { 
			rmap.length = bt_new.kd_ind+1;	// increase size of array if needed (nice D feature)
		}
		rmap[bt_new.kd_ind] = pcount-1;

		
		return 0;
	}
	
	
	/**
		Method that performs the agglomerative clustering.
	*/
	private void constructTree() 
	{
		int last = -1;
		
		while ( kdtree.vcount !=0 ) {
			if (last<0) {
				// initialize new chain with random point
				last = 0;
				TreeNode v = selectRandomPoint();
				
				chain[last] = v;
				
				removePoint(v);
				
				sim[last] = 0;				
			}
			
			// compute nearest-neightbor
			int result[2];
			kdtree.FindNeighbors(&result[0], 1, chain[last].point , KD_MAXCHECK);
			TreeNode s = nodes[rmap[result[0]]];
			
			
			
			float sm = similarity(chain[last],s);
			
			if (sm>sim[last]) { 
				// no RNN, adding s to the chain
				last++;
				chain[last] = s;
				removePoint(s);
				sim[last] = sm;
			}
			else {  
				// Found RNN, agglomerate the last two nodes in the chain
				if (sim[last]>SIM_THRESHOLD) { // ??
					int res = agglomerateAdd(chain[last],chain[last-1]);
					last -= 2;
				} else {
					last = -1; // discard the current chain
				}
			}
		}
	}



}